rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to get user data (only call if document exists)
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Helper function to get target user data (only call if document exists)
    function getTargetUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // Helper function to check if user is in the same family
    function isSameFamily(userId) {
      return request.auth != null && (
        request.auth.uid == userId || // Allow access to own data
        (
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          exists(/databases/$(database)/documents/users/$(userId)) &&
          getUserData().familyId != null &&
          getTargetUserData(userId).familyId != null &&
          getUserData().familyId == getTargetUserData(userId).familyId
        )
      );
    }

    // Helper function to check if user is a family admin
    function isFamilyAdmin() {
      return request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData().role == 'admin';
    }

    // Helper function to check if user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if user can read PHI for a patient
    function canReadPHI(patientUserId) {
      return isSignedIn() && (
        request.auth.uid == patientUserId || // User can read their own PHI
        (isFamilyAdmin() && isSameFamily(patientUserId)) // Family admin can read same-family PHI
      );
    }

    // Helper function to check if user can write PHI for a patient
    function canWritePHI(patientUserId) {
      return isSignedIn() && (
        request.auth.uid == patientUserId || // User can write their own PHI
        (isFamilyAdmin() && isSameFamily(patientUserId)) // Family admin can write same-family PHI
      );
    }

    // Users collection - Protected user data
    match /users/{userId} {
      // Allow users to read/write their own document
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow same-family members to read each other's user docs (includes family admins via isSameFamily check)
      // This enables family features like Zeina to query family members
      allow read: if isSignedIn() && isSameFamily(userId);
      
      // Allow family admin to update same-family member documents (for removing members, updating roles)
      // This enables admin to remove family members by setting their familyId to null
      // Two conditions: either same family check passes, OR admin's familyId matches the target user's familyId directly
      allow update: if isFamilyAdmin() && request.auth.uid != userId && (
        isSameFamily(userId) ||
        (
          // Direct familyId comparison as fallback
          exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
          exists(/databases/$(database)/documents/users/$(userId)) &&
          getUserData().familyId == resource.data.familyId
        )
      );

      // Allow user creation during registration
      allow create: if request.auth != null && request.auth.uid == userId;

      // Allow list queries for authenticated users (individual document access still controlled by read rules above)
      // This is needed for family member queries (e.g., Zeina healthContextService)
      // PHI protection maintained: only documents passing isSameFamily() read rule will be returned
      allow list: if isSignedIn();
      
      // Public profile subcollection - limited fields readable by same-family members
      match /public/profile {
        // Owner can read/write their own public profile
        allow read, write: if request.auth != null && request.auth.uid == userId;
        // Same-family members can read public profile (for caregiver UI)
        allow read: if isSignedIn() && isSameFamily(userId);
      }
      
      // Subcollections under user document - PHI protected
      match /medications/{medicationId} {
        // PHI access control: use same rules as top-level medications collection
        allow create: if canWritePHI(userId);
        allow read: if canReadPHI(userId);
        allow update, delete: if canWritePHI(userId);
      }
      
      match /symptoms/{symptomId} {
        // PHI access control: use same rules as top-level symptoms collection
        allow create: if canWritePHI(userId);
        allow read: if canReadPHI(userId);
        allow update, delete: if canWritePHI(userId);
      }
      
      match /family/{familyMemberId} {
        // Family member data - owner only access
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      match /alerts/{alertId} {
        // PHI access control: use same rules as top-level alerts collection
        allow create: if canWritePHI(userId);
        allow read: if canReadPHI(userId);
        allow update, delete: if canWritePHI(userId);
      }
      
      match /chatSessions/{sessionId} {
        // Chat sessions - owner only access
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Symptoms collection - PHI protected (used by Zeina healthContextService)
    match /symptoms/{symptomId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      // Queries must include userId filter matching the authenticated user or family member
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Medications collection - PHI protected (used by Zeina healthContextService)
    match /medications/{medicationId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Moods collection - PHI protected
    match /moods/{moodId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Medical History collection - PHI protected (used by Zeina healthContextService)
    match /medicalHistory/{historyId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Allergies collection - PHI protected
    match /allergies/{allergyId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Vitals collection - PHI protected
    match /vitals/{vitalId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Lab Results collection - PHI protected
    match /labResults/{labResultId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read/list only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Calendar Events collection - user's own events and family shared events
    match /calendarEvents/{eventId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid || // User's own events
        (resource.data.familyId != null && // Family shared events
         getUserData().familyId == resource.data.familyId)
      );
      allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Medication Adherence collection - PHI protected
    match /medication_adherence/{recordId} {
      allow create: if canWritePHI(request.resource.data.userId);
      allow read: if canReadPHI(resource.data.userId);
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Family invitation codes - Restricted access
    match /familyInvitations/{invitationId} {
      // Creator can create invitations if:
      // 1. User is authenticated
      // 2. User is creating invitation for themselves (invitedBy matches auth uid)
      // 3. User document exists and user is a member of the family they're creating invitation for
      // 4. Both user and invitation have non-null familyId values that match
      // Note: Firestore optimizes multiple get() calls to the same document
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.invitedBy &&
        request.resource.data.familyId != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyId == request.resource.data.familyId;
      
      // Restrict reads to only the creator to prevent unauthorized access to invitation codes
      // Code lookups should be done via Cloud Function for proper security validation
      allow read: if request.auth != null && request.auth.uid == resource.data.invitedBy;
      
      // Allow update by creator, or by the user claiming the invite code
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.invitedBy ||
        (
          resource.data.status == 'pending' &&
          request.resource.data.status == 'used' &&
          request.resource.data.usedBy == request.auth.uid
        )
      );
    }

    // Health Events collection - PHI protected
    match /healthEvents/{eventId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Alerts collection - PHI protected
    match /alerts/{alertId} {
      // PHI access control: create only if user can write PHI for the target user
      allow create: if canWritePHI(request.resource.data.userId);
      // PHI access control: read only if user can read PHI for the target user
      allow read: if canReadPHI(resource.data.userId);
      // PHI access control: update/delete only if user can write PHI for the target user
      allow update, delete: if canWritePHI(resource.data.userId);
    }

    // Families collection - Family-scoped access
    match /families/{familyId} {
      // Allow family members to read family documents (must be in same family)
      allow read: if isSignedIn() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData().familyId == familyId;

      // Allow family creation by authenticated users (for initial family setup)
      allow create: if isSignedIn();

      // Allow family admin to update family documents (restrictive to prevent membership manipulation)
      allow update: if isFamilyAdmin() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData().familyId == familyId;

      // Allow family admin to delete family documents (admin-only, must be in same family)
      allow delete: if isFamilyAdmin() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getUserData().familyId == familyId;

      // TODO: Consider locking down write access further if membership fields cannot be safely protected
      // Currently allows family admin updates - review if this exposes sensitive membership data
    }

    // Biometric profiles - user can only read/write their own
    match /biometric_profiles/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Auth logs - user can only read/write their own logs
    // Allow unauthenticated writes during biometric login (before user is authenticated)
    // but validate that the userId exists in the users collection and only allowed fields/types are written
    match /auth_logs/{logId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Allow authenticated users to write their own logs (with field type validation)
      allow write: if request.auth != null && 
        request.resource.data.userId == request.auth.uid &&
        // Validate required fields exist and are correct type
        request.resource.data.userId is string &&
        request.resource.data.timestamp is timestamp &&
        // Validate optional fields are correct type if present
        (request.resource.data.method == null || request.resource.data.method is string) &&
        (request.resource.data.success == null || request.resource.data.success is bool) &&
        (request.resource.data.deviceInfo == null || request.resource.data.deviceInfo is string);
      
      // Allow unauthenticated writes during biometric login (validate userId exists, timestamp is valid, and fields are restricted)
      allow create: if request.auth == null && 
        request.resource.data.userId != null &&
        request.resource.data.userId is string &&
        exists(/databases/$(database)/documents/users/$(request.resource.data.userId)) &&
        // Validate timestamp exists, is a timestamp type, and is not in the future
        request.resource.data.timestamp != null &&
        request.resource.data.timestamp is timestamp &&
        request.resource.data.timestamp <= request.time &&
        // Ensure timestamp is recent (after 2024-01-01 to prevent very old logs)
        request.resource.data.timestamp > timestamp.date(2024, 1, 1) &&
        // Validate optional fields are correct type if present (prevents injection of unexpected fields)
        (request.resource.data.method == null || request.resource.data.method is string) &&
        (request.resource.data.success == null || request.resource.data.success is bool) &&
        (request.resource.data.deviceInfo == null || request.resource.data.deviceInfo is string);
      // Note: Actual rate limiting (e.g., max 1 log per 5 minutes) should be implemented
      // in Cloud Functions or application code, as Firestore rules don't support duration arithmetic
      // Note: Field validation above ensures only expected fields with correct types can be written
    }

    // Dashboard configurations - users can only read/write their own dashboard config
    match /dashboardConfigs/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Observability collections - system metrics and events
    // Allow authenticated users to write metrics/events (for client-side observability)
    // Read access restricted to prevent data leakage
    match /observability_metrics/{metricId} {
      allow create: if isSignedIn();
      // Read access can be restricted further if needed (e.g., admin-only)
      allow read: if false; // No read access for now
    }

    match /observability_events/{eventId} {
      allow create: if isSignedIn();
      // Read access can be restricted further if needed (e.g., admin-only)
      allow read: if false; // No read access for now
    }

    match /alert_audits/{auditId} {
      allow create: if isSignedIn();
      // Allow read only if user can read the related alert
      allow read: if isSignedIn() && (
        resource.data.actorId == request.auth.uid || // User can read audits they created
        canReadPHI(resource.data.userId) // User can read audits for alerts they have access to
      );
    }
  }
} 